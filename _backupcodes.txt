# app.py
import os, sys
import streamlit as st
from dotenv import load_dotenv

# Ensure local package path (helps when launching from other dirs)
sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))

from core.check_all import check_all
from core.merge import merge_answers, pretty_status
from core.rules import next_missing

# Checkers (we pass context where relevant)
from core.questions.bundesland import check_bundesland
from core.questions.projektkosten import check_projektkosten
from core.questions.eigenanteil import check_eigenanteil
from core.questions.gruendungsjahr import check_gruendungsjahr
from core.questions.kategorie import check_kategorie
from core.questions.branche import check_branche

# Matching service
from matching import match_programs, render_matches

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

load_dotenv()
st.set_page_config(page_title="FÃ¶rdermittel-Chat", page_icon="ğŸ¤–", layout="wide")

# Minimal styles (optional)
st.markdown("""
<style>
.small { opacity:.8; font-size:.9em }
</style>
""", unsafe_allow_html=True)

# ---------- INIT SESSION STATE SAFELY ----------
if "chat" not in st.session_state:
    st.session_state["chat"] = []
if "answers" not in st.session_state:
    st.session_state["answers"] = {
        "kategorie": "not found",        # Innovation / Investition / Finanzierung
        "branche": "not found",
        "bundesland": "not found",
        "gruendungsjahr": "not found",   # only required if kategorie == Innovation
        "projektkosten_eur": "not found",
        "eigenanteil_eur": "not found",
    }
if "pending_key" not in st.session_state:
    st.session_state["pending_key"] = None
if "pending_label" not in st.session_state:
    st.session_state["pending_label"] = None
if "project_description" not in st.session_state:
    # We'll store the user's free-text description here for matching
    st.session_state["project_description"] = ""

# ---------- INTRO ONCE ----------
if not st.session_state["chat"]:
    st.session_state["chat"].append((
        "ai",
        "ğŸ‘‹ ErklÃ¤r dein Projekt bitte in ein paar SÃ¤tzen. "
        "Ich prÃ¼fe, welche der 6 Fragen damit bereits beantwortet sind."
    ))

# ---------- RENDER HISTORY ----------
for role, msg in st.session_state["chat"]:
    with st.chat_message("ai" if role == "ai" else "human"):
        st.markdown(msg)

# ---------- INPUT ----------
user_msg = st.chat_input("Beschreibe dein Projekt â€¦")
if user_msg:
    # 1) Show user's message immediately (before any analysis)
    with st.chat_message("human"):
        st.markdown(user_msg)

    # Keep/refresh the project description for matching (prefer the longest message)
    if len(user_msg) > len(st.session_state["project_description"]):
        st.session_state["project_description"] = user_msg

    # 2) Create an AI message bubble with a spinner while thinking
    with st.chat_message("ai"):
        with st.spinner("ğŸ¤– Der Agent denkt â€¦"):
            # ANALYZE (context-aware routing first, then fallback extractors)
            pending_key = st.session_state.get("pending_key")
            pending_label = st.session_state.get("pending_label")
            partial = {}
            used_direct = False

            if pending_key:
                # Route the reply to the relevant checker and give it the question as context
                if pending_key == "bundesland":
                    out = check_bundesland(user_msg, context=pending_label)
                    if out.get("answered"):
                        partial = {"bundesland": out["value"]}
                        used_direct = True

                elif pending_key == "projektkosten_eur":
                    out = check_projektkosten(user_msg, context=pending_label)
                    if out.get("answered"):
                        partial = {"projektkosten_eur": out["value"]}
                        used_direct = True

                elif pending_key == "eigenanteil_eur":
                    out = check_eigenanteil(user_msg, context=pending_label)
                    if out.get("answered"):
                        partial = {"eigenanteil_eur": out["value"]}
                        used_direct = True

                elif pending_key == "gruendungsjahr":
                    out = check_gruendungsjahr(user_msg)  # add context in file if desired
                    if out.get("answered"):
                        partial = {"gruendungsjahr": out["value"]}
                        used_direct = True

                elif pending_key == "kategorie":
                    out = check_kategorie(user_msg)
                    if out.get("answered"):
                        partial = {"kategorie": out["value"]}
                        used_direct = True

                elif pending_key == "branche":
                    out = check_branche(user_msg)
                    if out.get("answered"):
                        partial = {"branche": out["value"]}
                        used_direct = True

            # If not a direct, contexted reply â†’ run the general extractors on free text
            if not used_direct:
                partial = check_all(user_msg)

            # Merge recognized fields
            st.session_state["answers"] = merge_answers(st.session_state["answers"], partial)

            # Build summary + figure out next question (order + Innovation rule)
            status = pretty_status(st.session_state["answers"])
            next_key, next_label = next_missing(st.session_state["answers"])

            if next_label:
                st.session_state["pending_key"] = next_key
                st.session_state["pending_label"] = next_label
                bot = "Danke! Bisher habe ich erkannt:\n\n" + status + f"\n\n**{next_label}**"
                # After spinner closes, show message
                st.markdown(bot)
            else:
                st.session_state["pending_key"] = None
                st.session_state["pending_label"] = None
                bot = (
                    "Top, alle benÃ¶tigten Angaben sind da:\n\n" + status +
                    "\n\nDu kannst jederzeit korrigieren (z. B. â€Bundesland ist Bayernâ€œ)."
                )
                # After spinner closes, show the computed bot message
                st.markdown(bot)

                # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                # Run matching service and render Top-3 (styled + contact form)
                # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                st.markdown("## ğŸ¯ Top-3 FÃ¶rdermittel passend zu deinem Projekt")
                json_path = os.path.join(os.path.dirname(__file__), "foerdermittel_normalized.json")
                matches = match_programs(
                    st.session_state["answers"],
                    st.session_state.get("project_description", ""),
                    json_path=json_path,
                    top_k=3
                )
                render_matches(matches)

    # 3) Persist both messages into history for future reruns
    st.session_state["chat"].append(("human", user_msg))
    st.session_state["chat"].append(("ai", bot))


-----------------------------------


# matching.py
import json
import math
import os
import re
from collections import Counter, defaultdict
from typing import Dict, List, Optional

# Load .env (harmless if called twice)
try:
    from dotenv import load_dotenv  # type: ignore
    load_dotenv()
except Exception:
    pass

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Optional OpenAI Embeddings (hybrid ranking)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()

_openai_available = False
_client = None
_embedding_model = "text-embedding-3-small"  # switch to -large if you want max accuracy

if OPENAI_API_KEY:
    try:
        # New SDK (2024+)
        from openai import OpenAI  # type: ignore
        _client = OpenAI(api_key=OPENAI_API_KEY)
        _openai_available = True
    except Exception:
        try:
            import openai  # type: ignore
            openai.api_key = OPENAI_API_KEY
            _client = openai
            _openai_available = True
            _embedding_model = "text-embedding-3-small"
        except Exception:
            _openai_available = False
            _client = None

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Basic German tokenization + tiny stopword list (no external deps)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

GERMAN_STOPWORDS = {
    "und","oder","der","die","das","ein","eine","einer","einem","einen","den","dem",
    "zu","mit","fÃ¼r","im","in","am","an","auf","aus","als","bei","vom","von","des",
    "ist","sind","werden","wird","auch","sowie","bis","dass","daÃŸ","nach","vor",
    "durch","ohne","unter","Ã¼ber","so","wenn","diese","dieser","dieses","denn","etc",
    "sie","er","es","wir","ihr","ihnen","ihre","ihren","ihrer","euch","man","kann",
    "kÃ¶nnen","nicht","nur","noch","schon"
}

UMLAUT_MAP = str.maketrans({
    "Ã¤": "ae", "Ã¶": "oe", "Ã¼": "ue",
    "Ã„": "ae", "Ã–": "oe", "Ãœ": "ue",
    "ÃŸ": "ss"
})

def normalize_text(text: str) -> str:
    if not text:
        return ""
    text = text.translate(UMLAUT_MAP).lower()
    text = re.sub(r"[^\w\s]", " ", text, flags=re.UNICODE)
    text = re.sub(r"\s+", " ", text).strip()
    return text

def tokenize(text: str) -> List[str]:
    norm = normalize_text(text)
    return [t for t in norm.split(" ") if t and t not in GERMAN_STOPWORDS and not t.isdigit()]

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Lightweight BM25 (no external libraries)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def bm25_scores(query_tokens: List[str], docs_tokens: List[List[str]], k1=1.5, b=0.75) -> List[float]:
    if not docs_tokens:
        return []
    N = len(docs_tokens)
    doc_lens = [len(d) for d in docs_tokens]
    avgdl = sum(doc_lens) / N if N else 0.0

    df = defaultdict(int)
    query_set = set(query_tokens)
    for dtoks in docs_tokens:
        unique = set(dtoks)
        for qt in query_set:
            if qt in unique:
                df[qt] += 1

    idf = {}
    for qt in query_set:
        idf[qt] = math.log((N - df[qt] + 0.5) / (df[qt] + 0.5) + 1.0)

    scores = []
    for idx, dtoks in enumerate(docs_tokens):
        tf = Counter(dtoks)
        denom = k1 * (1 - b + b * (doc_lens[idx] / (avgdl or 1.0)))
        s = 0.0
        for qt in query_tokens:
            f = tf.get(qt, 0)
            if f == 0:
                continue
            s += idf[qt] * ((f * (k1 + 1)) / (f + denom))
        scores.append(s)
    return scores

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Filters
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BUNDESLAND_SYNONYMS = {
    "nrw": "Nordrhein-Westfalen",
    "nordrhein westfalen": "Nordrhein-Westfalen",
    "baden wuerttemberg": "Baden-WÃ¼rttemberg",
    "baden-wuerttemberg": "Baden-WÃ¼rttemberg",
    "bayern": "Bayern",
    "berlin": "Berlin",
    "brandenburg": "Brandenburg",
    "bremen": "Bremen",
    "hamburg": "Hamburg",
    "hessen": "Hessen",
    "mecklenburg vorpommern": "Mecklenburg-Vorpommern",
    "niedersachsen": "Niedersachsen",
    "rheinland pfalz": "Rheinland-Pfalz",
    "saarland": "Saarland",
    "sachsen": "Sachsen",
    "sachsen anhalt": "Sachsen-Anhalt",
    "schleswig holstein": "Schleswig-Holstein",
    "thueringen": "ThÃ¼ringen",
    "thÃ¼ringen": "ThÃ¼ringen",
}

VALID_KATEGORIEN = {"Innovation", "Investition", "Finanzierung"}

def normalize_bundesland(bl: str) -> str:
    if not bl or bl == "not found":
        return ""
    key = normalize_text(bl).replace("-", " ").strip()
    return BUNDESLAND_SYNONYMS.get(key, bl)

def parse_number_eur(val) -> float:
    if val is None or val == "not found":
        return -1.0
    if isinstance(val, (int, float)):
        try:
            return float(val)
        except Exception:
            return -1.0
    s = str(val).replace(".", "").replace(" ", "").replace(",", ".")
    try:
        return float(s)
    except Exception:
        return -1.0

def _has_zuschuss(foerderart_list: List[str]) -> bool:
    if not foerderart_list:
        return False
    return any("zuschuss" in (fa or "").lower() for fa in foerderart_list)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Data I/O
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def load_programs(json_path: str) -> List[Dict]:
    if not os.path.isabs(json_path):
        base = os.path.dirname(os.path.abspath(__file__))
        json_path = os.path.join(base, json_path)
    with open(json_path, "r", encoding="utf-8") as f:
        return json.load(f)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Filtering
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def apply_filters(programs: List[Dict], answers: Dict) -> List[Dict]:
    """
    Filters:
      1) Kategorie (Innovation, Investition, Finanzierung)
      2) Bundesland: keep only items with funding_area == BL OR "Bund"
      3) Zuschuss filter: if eigenanteil == 0 => drop Zuschuss FÃ¶rdermittel
    """
    kategorie = answers.get("kategorie", "")
    bl = normalize_bundesland(answers.get("bundesland", ""))
    eigen = parse_number_eur(answers.get("eigenanteil_eur"))

    filtered = []
    for p in programs:
        # (1) Kategorie
        cat = (p.get("funding_category") or "").strip()
        if kategorie in VALID_KATEGORIEN and cat != kategorie:
            continue

        # (2) Bundesland (or Bund)
        area = (p.get("funding_area") or "").strip()
        if bl and not (area == bl or area == "Bund"):
            continue

        # (3) Zuschuss filter if eigenanteil is 0
        foerderart = p.get("fÃ¶rderart") or []
        if eigen == 0.0 and _has_zuschuss(foerderart):
            continue

        filtered.append(p)

    return filtered

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Text prep
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def build_doc_text(p: Dict, for_embedding: bool = False) -> str:
    parts = [
        p.get("title", ""),
        p.get("description", ""),
        p.get("funding_category", ""),
        p.get("funding_area", ""),
        " ".join(p.get("fÃ¶rderart") or []),
    ]
    alldetails = (p.get("alldetails") or "").strip()
    if for_embedding and alldetails:
        parts.append(alldetails[:2000])
    return " \n".join([str(x) for x in parts if x])

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Embedding utils
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _embed_texts(texts: List[str]) -> Optional[List[List[float]]]:
    if not _openai_available or not _client:
        return None
    try:
        if hasattr(_client, "embeddings"):
            resp = _client.embeddings.create(model=_embedding_model, input=texts)
            return [d.embedding for d in resp.data]
        if hasattr(_client, "Embedding"):
            resp = _client.Embedding.create(model=_embedding_model, input=texts)
            return [d["embedding"] for d in resp["data"]]
    except Exception:
        return None
    return None

def _cosine(a: List[float], b: List[float]) -> float:
    if not a or not b or len(a) != len(b):
        return 0.0
    dot = 0.0; na = 0.0; nb = 0.0
    for x, y in zip(a, b):
        dot += x * y; na += x * x; nb += y * y
    if na == 0.0 or nb == 0.0:
        return 0.0
    return dot / (math.sqrt(na) * math.sqrt(nb))

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Matching main
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _query_text_from_answers(answers: Dict, project_text: str) -> str:
    bits = [project_text or ""]
    if answers.get("branche") and answers["branche"] != "not found":
        bits.append(f"Branche: {answers['branche']}")
    if answers.get("kategorie") in VALID_KATEGORIEN:
        bits.append(f"Kategorie: {answers['kategorie']}")
    if answers.get("projektkosten_eur") not in (None, "not found"):
        bits.append(f"Projektkosten (EUR): {answers['projektkosten_eur']}")
    if answers.get("eigenanteil_eur") not in (None, "not found"):
        bits.append(f"Eigenanteil (EUR): {answers['eigenanteil_eur']}")
    if answers.get("bundesland") and answers["bundesland"] != "not found":
        bits.append(f"Bundesland: {answers['bundesland']}")
    q = " | ".join([b for b in bits if b])
    return q[:2000] if q else "FÃ¶rdermittel fÃ¼r Unternehmen"

def match_programs(
    answers: Dict,
    project_text: str,
    json_path: str = "foerdermittel_normalized.json",
    top_k: int = 3
) -> List[Dict]:
    """
    1) Load & filter JSON (Kategorie, Bundesland/Bund, Zuschuss if Eigenanteil=0)
    2) Rank filtered programs using a hybrid strategy:
       - Embedding cosine similarity (OpenAI)
       - BM25 lexical score
       Combined score = 0.6 * embedding + 0.4 * BM25 (tunable)
    Falls back to BM25-only if no API key or embedding call fails.
    """
    programs = load_programs(json_path)
    filtered = apply_filters(programs, answers)
    if not filtered:
        return []

    query_text = _query_text_from_answers(answers, project_text)

    # BM25 side
    docs_text_bm25 = [build_doc_text(p, for_embedding=False) for p in filtered]
    docs_tokens = [tokenize(t) for t in docs_text_bm25]
    query_tokens = tokenize(project_text or "") or tokenize(query_text)
    bm25 = bm25_scores(query_tokens, docs_tokens)
    max_bm25 = max(bm25) if bm25 else 1.0
    norm_bm25 = [s / max_bm25 if max_bm25 > 0 else 0.0 for s in bm25]

    # Embedding side
    embed_scores = None
    if _openai_available:
        query_embed = _embed_texts([query_text])
        if query_embed:
            qv = query_embed[0]
            docs_text_embed = [build_doc_text(p, for_embedding=True) for p in filtered]
            doc_embeds = _embed_texts(docs_text_embed)
            if doc_embeds and len(doc_embeds) == len(filtered):
                embed_scores = [_cosine(qv, dv) for dv in doc_embeds]

    # Combine
    if embed_scores:
        min_e, max_e = min(embed_scores), max(embed_scores)
        norm_emb = (
            [(s - min_e) / (max_e - min_e) for s in embed_scores]
            if max_e - min_e > 1e-9 else [0.0 for _ in embed_scores]
        )
        alpha = 0.6
        final_scores = [alpha * e + (1 - alpha) * b for e, b in zip(norm_emb, norm_bm25)]
    else:
        final_scores = norm_bm25

    ranked = sorted(zip(filtered, final_scores), key=lambda x: x[1], reverse=True)
    top = []
    for p, s in ranked[:top_k]:
        q = dict(p)
        q["score"] = float(s)
        top.append(q)
    return top

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Rendering (style like your old app; no external side-effects)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _contact_form(matches: List[Dict]):
    import streamlit as st
    st.markdown("<a name='kontaktformular'></a>", unsafe_allow_html=True)

    with st.form("lead_form", clear_on_submit=True):
        st.markdown("### Herzlichen GlÃ¼ckwunsch - der erste Schritt ist getan!")
        st.markdown("Checke jetzt kostenfrei mit uns die FÃ¶rderfÃ¤higkeit fÃ¼r dein Projekt.")
        st.markdown("Bitte fÃ¼lle das folgende Formular aus - wir kommen direkt auf dich zu.")

        # programme selector (from shown matches)
        titles = [m.get("title", "Ohne Titel") for m in matches] or ["Allgemeine Anfrage"]
        chosen = st.selectbox("Programm (optional)", options=titles, index=0)

        unternehmen = st.text_input(label="", placeholder="Unternehmensname *")
        name = st.text_input(label="", placeholder="Vorname, Nachname *")
        email = st.text_input(label="", placeholder="E-Mail-Adresse *")
        phone = st.text_input(label="", placeholder="Telefonnummer (optional)")

        st.markdown(
            "Die Welt der FÃ¶rdermittel ist stÃ¤ndig im Wandel â€“ gerne halten wir Sie in regelmÃ¤ÃŸigen AbstÃ¤nden auf dem Laufenden. "
            "Sie kÃ¶nnen diese Benachrichtigungen jederzeit abbestellen."
        )
        newsletter_optin = st.checkbox(
            "Ich stimme zu, andere Benachrichtigungen von FÃ¶rdermittel-Vergleich.de zu erhalten."
        )

        st.markdown(
            "Um Ihnen das Ergebnis Ihres FÃ¶rderchecks mitzuteilen, mÃ¼ssen wir Ihre personenbezogenen Daten speichern und verarbeiten."
        )
        datenschutz_optin = st.checkbox(
            "Ich stimme zu, dass meine Angaben zur Kontaktaufnahme und zur Bearbeitung meines Anliegens "
            "(z. B. zur Terminvereinbarung) gemÃ¤ÃŸ der DatenschutzerklÃ¤rung verarbeitet werden.*",
            help="Pflichtfeld"
        )

        submitted = st.form_submit_button("Jetzt kostenfrei anfragen")
        if submitted:
            errors = []
            if not unternehmen.strip():
                errors.append("Bitte geben Sie den Unternehmensnamen an.")
            if not name.strip():
                errors.append("Bitte geben Sie Ihren Namen an.")
            if not email.strip():
                errors.append("Bitte geben Sie Ihre E-Mail-Adresse an.")
            if not datenschutz_optin:
                errors.append("Sie mÃ¼ssen der DatenschutzerklÃ¤rung zustimmen.")

            import re
            if email and not re.match(r"[^@]+@[^@]+\.[^@]+", email):
                errors.append("Bitte geben Sie eine gÃ¼ltige E-Mail-Adresse ein.")

            if errors:
                for e in errors:
                    st.error(e)
            else:
                st.session_state["lead_submission"] = {
                    "programm": chosen,
                    "unternehmen": unternehmen,
                    "name": name,
                    "email": email,
                    "phone": phone,
                    "newsletter_optin": bool(newsletter_optin),
                    "datenschutz_optin": bool(datenschutz_optin),
                }
                st.success("Vielen Dank â€“ wir melden uns innerhalb von 24 Stunden mit passenden FÃ¶rdermÃ¶glichkeiten!")

def render_matches(matches: List[Dict]):
    """
    Styled cards + meta line + jump-link to contact form (like your old app).
    No external saving; only writes to session_state on form submit.
    """
    try:
        import streamlit as st
    except Exception:
        # Non-Streamlit fallback
        for i, m in enumerate(matches, 1):
            print(f"{i}. {m.get('title','(ohne Titel)')}")
        return

    if not matches:
        st.info("Kein Treffer nach den Filtern. Ã„ndere eine Angabe oder beschreibe dein Projekt ausfÃ¼hrlicher.")
        _contact_form(matches)  # still allow contact
        return

    # Intro + small hint (mirroring your tone)
    st.markdown(
        "ğŸš€ Herzlichen GlÃ¼ckwunsch! Aufgrund Ihrer Angaben scheint es FÃ¶rdermÃ¶glichkeiten fÃ¼r Ihr Projekt zu geben."
    )
    st.caption("_Hinweis: Die Reihenfolge spiegelt die Relevanz wider (oben = passender)._")

    # Cards
    for m in matches:
        title = m.get("title", "Ohne Titel")
        desc = m.get("description", "")
        area = m.get("funding_area", "â€“")
        art_val = m.get("fÃ¶rderart", [])
        art = ", ".join(art_val) if isinstance(art_val, list) else (art_val or "â€“")
        amount = m.get("hÃ¶he_der_fÃ¶rderung") or "â€“"
        score = m.get("score", None)

        with st.container(border=True):
            st.markdown(f"### {title}")
            if desc:
                st.write(desc)

            meta_parts = [
                f"ğŸ“ **Gebiet:** {area}",
                f"ğŸ’¶ **Art:** {art}",
                f"ğŸ’° **HÃ¶he:** {amount}",
            ]
            if isinstance(score, (int, float)):
                meta_parts.append(f"ğŸ“Š **Score:** {score:.3f}")
            st.markdown(" &nbsp;&nbsp; ".join(meta_parts))

            # bold, no-underline jump link to form
            st.markdown(
                "<a href='#kontaktformular' style='text-decoration:none; font-weight:700;'>"
                "âœ Interesse? Zum Kontaktformular</a>",
                unsafe_allow_html=True
            )

    # Contact form below the list
    _contact_form(matches)
